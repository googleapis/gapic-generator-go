// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gengapic

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/ghodss/yaml"
	conf "github.com/googleapis/gapic-generator-go/internal/grpc_service_config"
	"google.golang.org/genproto/googleapis/api/serviceconfig"
	"google.golang.org/protobuf/encoding/protojson"
)

// Define a type to represent supported network transports.
type transport int

// Declare the transports we support for generation.
const (
	grpc transport = iota
	rest
)

// static error for the most critical argument
var errInvalidPackageParam = errors.New("need parameter in format: go-gapic-package=client/import/path;packageName")

// DeprecatedArgs are plugin arguments we want to explicitly error on, so invokers know that the
// option is no longer supported.
var DeprecatedArgs map[string]error = map[string]error{
	"gapic-service-config": errors.New("removed, use api-service-config instead"),
}

// SupportedBooleanArgs expose boolean plugin arguments (presence enables option).
var SupportedBooleanArgs map[string]func() configOption = map[string]func() configOption{
	"metadata":           generateGAPICMetadata,
	"diregapic":          generateAsDIREGAPIC,
	"rest-numeric-enums": enableRESTNumericEnums,
	"omit-snippets":      enableOmitSnippets,
}

// SupportedValueArgs are arguments that are supplied in the form <key>=<value>.
// The map is keyed by the argument key.
var SupportedValueArgs map[string]func(string) configOption = map[string]func(string) configOption{
	"go-gapic-package":    withGoGAPICPackage,
	"api-service-config":  withAPIServiceConfigPath,
	"grpc-service-config": withGRPCServiceConfigPath,
	"module":              withModulePrefix,
	"release-level":       withReleaseLevel,
	"transport":           withTransports,
}

// SupportedPrefixArgs are a special case of the value arg that use a string prefix.
// The primary use is for dynamic package overrides, which can be used to override the package
// for a particular input in the example form:
//
//	Mgoogle/storage/v2/storage.proto=cloud.google.com/go/storage/internal/apiv2/stubs
//
// Recommendation: avoid adding more of these as they complicate processing.
var SupportedPrefixArgs map[string]func(string) configOption = map[string]func(string) configOption{
	"M": withPackageOverride,
}

// Configuration needed to drive the operation of the plugin.
// The options should be treated as immutable once instantiated.
type generatorConfig struct {
	// The fully qualified package path, e.g. "cloud.google.com/go/foo/v1/foopb"
	pkgPath string
	// The package name, e.g. "foopb"
	pkgName string
	// Output directory for the generated artifacts.
	outDir string

	// Should GAPIC metadata be generated
	generateGAPICMetadata bool

	// Should the generator respect DIREGAPIC limitations
	// If the input artifacts are synthetic (e.g. compiled from another IDL source such as a discovery document) then
	// some protobuf-behaviors should not be relied upon.
	generateAsDIREGAPIC bool

	// Should the generator code generator numeric enums for REST calls
	// TODO: rename this in a subsquent refactor
	restNumericEnum bool

	// should generated snippets be omitted (generated by default)
	// TODO: rename this in a subsequent refactor
	omitSnippets bool

	// Parsed Service Configuration.
	APIServiceConfig *serviceconfig.Service

	// Parsed gRPC Service Configuration.
	gRPCServiceConfig conf.Config

	// prefix for the enclosing module
	modulePrefix string

	// release level of the generated artifacts
	// TODO: rename this in a subsequent refactor
	relLvl string

	// which network transports are being generated.
	// TODO: rename this and make it easier to get right (likely a map) in a refactor
	transports []transport

	// Package naming overrides, keyed by filepath.
	pkgOverrides map[string]string
}

// Signature for configuration arguments.
// Errors are part of the signature to allow options to provide validation feedback early.
// Config options that return errors should not modify the configuration.
type configOption func(*generatorConfig) error

// configFromRequest consumes the "parameter" field from the CodeGenerationRequest to produce a configuration.
// This should be a comma seperated list of plugin arguments, and each one is handled in the order it appears.
//
// All plugin arguments understood by this plugin should be registered in one of the well known option collections, which
// are used to process the input parameters:
// DeprecatedArgs
// SupportedBooleanArgs
// SupportedValueArgs
// SupportedPrefixArgs
func configFromRequest(generationParameter *string) (*generatorConfig, error) {
	if generationParameter == nil {
		return nil, errors.New("generationParameter is nil, cannot configure")
	}

	cfg := &generatorConfig{}

	// params are comma seperated.  Split and process each individually.
	for _, s := range strings.Split(*generationParameter, ",") {
		// Normalize to ensure we're not dealing with spacing issues.
		pluginArg := strings.TrimSpace(s)

		// Ignore empty args.
		if pluginArg == "" {
			continue
		}

		// Handle deprecated arguments first.
		if err, ok := DeprecatedArgs[pluginArg]; ok {
			return nil, err
		}
		// Handle the boolean keyword args, e.g. non key=value style arguments.
		if o, ok := SupportedBooleanArgs[pluginArg]; ok {
			if err := o()(cfg); err != nil {
				// It's unlikely that any boolean option will surface errors, but we do it here
				// lest we are surprised in the future.
				return nil, fmt.Errorf("plugin arg %q invalid: %w", pluginArg, err)
			}
			continue
		}

		// Handle value args by parsing key=value parts.
		e := strings.IndexByte(pluginArg, '=')
		if e > 0 {
			key, val := pluginArg[:e], pluginArg[e+1:]
			if valueOpt, ok := SupportedValueArgs[key]; ok {
				if err := valueOpt(val)(cfg); err != nil {
					return nil, fmt.Errorf("plugin arg %q invalid: %w", pluginArg, err)
				}
				continue
			}
		}

		// Now, handle prefix args by scanning registered prefixes.
		for prefix, prefixOpt := range SupportedPrefixArgs {
			if strings.HasPrefix(pluginArg, prefix) {
				prefixLen := len(prefix)
				if err := prefixOpt(pluginArg[prefixLen:])(cfg); err != nil {
					return nil, fmt.Errorf("plugin arg %q invalid: %w", pluginArg, err)
				}
				continue
			}
		}

	}
	// Now that all options are processed, normalized and validate.
	if err := validateAndNormalizeOptions(cfg); err != nil {
		return nil, err
	}
	return cfg, nil
}

// This function provides an opportunity to validate that a configuration adheres to expectations
// and the configuration adheres to expectations (e.g. required fields are present, fields with relationships
// are not in conflict).
//
// It also handles cases such as default values (e.g. what transports are enabled) where the configuration is more
// than a simple boolean option.
func validateAndNormalizeOptions(cfg *generatorConfig) error {
	// Normalize transports.  If no transports are specified, generate gRPC only by default.
	if len(cfg.transports) == 0 {
		cfg.transports = []transport{grpc}
	}

	// REST enums are not supported by DIREGAPIC.
	if cfg.generateAsDIREGAPIC && cfg.restNumericEnum {
		return errors.New("incompatible features: diregapic and rest numeric enums")
	}

	// Certain configuration details must be present.
	if cfg.pkgPath == "" || cfg.pkgName == "" || cfg.outDir == "" {
		return errInvalidPackageParam
	}

	if cfg.modulePrefix != "" {
		if !strings.HasPrefix(cfg.outDir, cfg.modulePrefix) {
			return fmt.Errorf("go-gapic-package %q does not match prefix %q", cfg.outDir, cfg.modulePrefix)
		}
		cfg.outDir = strings.TrimPrefix(cfg.outDir, cfg.modulePrefix+"/")
	}

	return nil
}

// withGoGapicPackage parses the value argument based on the typical
// pattern:
// <packagepath>;<packagename>
// Example:
// cloud.google.com/go/foo/v1/foopb;foopb
func withGoGAPICPackage(s string) configOption {
	p := strings.IndexByte(s, ';')

	if p < 0 {
		return func(cfg *generatorConfig) error {
			return errInvalidPackageParam
		}
	}
	return func(cfg *generatorConfig) error {
		cfg.pkgPath = s[0:p]
		cfg.pkgName = s[p+1:]
		cfg.outDir = filepath.FromSlash(cfg.pkgPath)
		return nil
	}
}

// generateGAPICMetadata enables generation of GAPIC metadata.
func generateGAPICMetadata() configOption {
	return func(cfg *generatorConfig) error {
		cfg.generateGAPICMetadata = true
		return nil
	}
}

// generateAsDIREGAPIC is a behavioral flag that ensures code generation respects
// special DIREGAPIC constraints.  A DIREGAPIC is a set of input artifacts that were
// reverse-compiled from an API Discovery document, rather than directly from service
// protos (e.g. compute).
func generateAsDIREGAPIC() configOption {
	return func(cfg *generatorConfig) error {
		cfg.generateAsDIREGAPIC = true
		return nil
	}
}

// enableRESTNumericEnums is a behavioral flag that causes the generated REST clients
// to send the numeric value for enum fields rather than the string label.
func enableRESTNumericEnums() configOption {
	return func(cfg *generatorConfig) error {
		cfg.restNumericEnum = true
		return nil
	}
}

// Should automatic generation of snippets be disabled.
func enableOmitSnippets() configOption {
	return func(cfg *generatorConfig) error {
		cfg.omitSnippets = true
		return nil
	}
}

// Specifies the path to the API service config file.
// Option parses the path and does basic validation.
func withAPIServiceConfigPath(s string) configOption {
	return func(cfg *generatorConfig) error {

		if s == "" {
			return fmt.Errorf("provided API service config path was empty")
		}
		y, err := os.ReadFile(s)
		if err != nil {
			return fmt.Errorf("error reading API service config path (%q): %v", s, err)
		}

		j, err := yaml.YAMLToJSON(y)
		if err != nil {
			return fmt.Errorf("error converting API service config from YAML to JSON: %v", err)
		}

		sc := &serviceconfig.Service{}
		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(j, sc); err != nil {
			return fmt.Errorf("error unmarshaling api service config: %v", err)
		}

		// An API Service Config will always have a `name` so if it is not populated,
		// it's an invalid config.
		if sc.GetName() == "" {
			return fmt.Errorf("invalid API service config contents")
		}
		cfg.APIServiceConfig = sc
		return nil
	}
}

// Specifies the path to the gRPC service config file.
func withGRPCServiceConfigPath(s string) configOption {
	return func(cfg *generatorConfig) error {

		if s == "" {
			return fmt.Errorf("provided gRPC service config path was empty")
		}

		f, err := os.Open(s)
		if err != nil {
			return fmt.Errorf("error opening gRPC service config(%q): %v", s, err)
		}
		defer f.Close()

		sc, err := conf.New(f)
		if err != nil {
			return fmt.Errorf("error parsing gPRC service config: %v", err)
		}
		cfg.gRPCServiceConfig = sc
		return nil
	}
}

// Specifies the module prefix.
func withModulePrefix(s string) configOption {
	return func(cfg *generatorConfig) error {
		cfg.modulePrefix = s
		return nil
	}
}

// Specifies the release level of the generated artifacts.
func withReleaseLevel(s string) configOption {
	return func(cfg *generatorConfig) error {
		// TODO: this should be validated against a well defined set of levels
		cfg.relLvl = s
		return nil
	}
}

// withPackageOverride handles a package naming override.
// The `M` prefix is not passed as part of the string, only the remaining substring.
func withPackageOverride(s string) configOption {
	e := strings.IndexByte(s, '=')
	if e < 0 {
		return func(cfg *generatorConfig) error {
			return fmt.Errorf("invalid package override format, should be <file>=<renamed file>: %q", s)
		}
	}
	key, val := s[:e], s[e+1:]
	if val == "" {
		return func(cfg *generatorConfig) error {
			return fmt.Errorf("invalid plugin option value, missing value in key=value: %q", s)
		}
	}
	return func(cfg *generatorConfig) error {
		if cfg.pkgOverrides == nil {
			cfg.pkgOverrides = make(map[string]string)
		}
		cfg.pkgOverrides[key] = val
		return nil
	}
}

// Utility function for stringifying the Transport enum
func (t transport) String() string {
	switch t {
	case grpc:
		return "grpc"
	case rest:
		return "rest"
	default:
		// Add new transport variants as need be.
		return fmt.Sprintf("%d", int(t))
	}
}

// Specifies the requested network transports to generate.
func withTransports(s string) configOption {
	transports := map[transport]bool{}
	for _, t := range strings.Split(s, "+") {
		switch t {
		case "grpc":
			transports[grpc] = true
		case "rest":
			transports[rest] = true
		default:
			return func(cfg *generatorConfig) error {
				return fmt.Errorf("invalid transport option: %q", t)
			}
		}

	}
	return func(cfg *generatorConfig) error {
		for t := range transports {
			cfg.transports = append(cfg.transports, t)
		}
		// TODO: remove this after refactor, its a weak expectation
		sort.Slice(cfg.transports, func(i, j int) bool {
			return cfg.transports[i] < cfg.transports[j]
		})
		return nil
	}
}
